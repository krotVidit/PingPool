// ======= ./main.go =======
package main

import (
	"fmt"
	"net/http"
	"time"

	"ping/app/workerpool"
)

// TODO: В данной вертке будет реаилзована возможность вызывать  в цикле пинг
func main() {
	const workerCount = 3
	client := &http.Client{Timeout: time.Second * 10}
	pool := workerpool.NewPool(workerCount, client)

	urls, err := workerpool.LoadUrls("urls.json")
	if err != nil {
		fmt.Println("Ошибка", err)
		return
	}

	pool.WriteChanIn(urls)
	pool.Wait()

	for result := range pool.ResOutChan() {
		fmt.Println(result.Report())
	}

	go workerpool.GracefulShutdown(pool)
}

// ======= ./workerpool/pool.go =======
// Package workerpool - пакет служащий для реализации паттерна workerpool
// Создание структуры и конструктора Pool - где уже создается Пул Ворекров
package workerpool

import (
	"net/http"
	"sync"
)

type Pool struct {
	wg          sync.WaitGroup
	client      *http.Client
	workerCount int
	stopped     bool
	mu          sync.Mutex
	in          chan string
	out         chan Result
}

func NewPool(workerCount int, client *http.Client) *Pool {
	p := &Pool{
		client:      client,      // Можно ещё создать метод по умолчанию который будет создавать клиента
		workerCount: workerCount, // Пригодится всё равно
		stopped:     false,       // по сути мы же можем реализовать один прогон или бесконечный через это
		in:          make(chan string),
		out:         make(chan Result),
	}

	for i := 0; i < workerCount; i++ {
		p.wg.Add(1)
		go p.worker()
	}
	return p
}

// ======= ./workerpool/worker.go =======
// Package workerpool - пакет служащий для реализации паттерна workerpool
// timeTrack - может принять в себя любуфую функцию и посчитать время её выполнения
// worker - получает результаты запроса из handleURL и отправляет их структуру Results
package workerpool

import "time"

func (p *Pool) worker() {
	defer p.wg.Done()

	for url := range p.in {
		p.out <- p.handleURL(url)
	}
}

func timeTrack[T any](f func() (T, error)) (res T, duration time.Duration, err error) {
	start := time.Now()
	res, err = f()
	return res, time.Since(start), err
}

func (p *Pool) handleURL(url string) Result {
	status, duration, err := timeTrack(func() (string, error) {
		resp, err := p.client.Get(url)
		if err != nil {
			return "", err
		}
		defer resp.Body.Close()
		return resp.Status, nil
	})
	return newResult(url, status, duration, err)
}

// ======= ./workerpool/result.go =======
// Package workerpool - пакет служащий для реализации паттерна workerpool
// Results - хранит в себе результаты ответа запроса
// Report формирует удобный вывод результатов с помощью методов DurationString и StatusString
package workerpool

import (
	"fmt"
	"time"
)

type Result struct {
	URL      string
	Status   string
	Duration time.Duration
	Err      error
}

func newResult(URL, Status string, Duration time.Duration, Err error) Result {
	return Result{
		URL:      URL,
		Status:   Status,
		Duration: Duration,
		Err:      Err,
	}
}

func (r Result) Report() string {
	if r.Err != nil {
		return fmt.Sprintf("%-8s %-35s %v", r.StatusString(), r.URL, r.Err)
	}

	return fmt.Sprintf("%-8s %-35s %-5s %s", r.StatusString(), r.URL, r.Status, r.DurationString())
}

func (r Result) DurationString() string {
	if r.Duration < time.Second {
		return fmt.Sprintf("%dms", r.Duration.Milliseconds())
	}
	return fmt.Sprintf("%.2fs", r.Duration.Seconds())
}

func (r Result) StatusString() string {
	if r.Err != nil {
		return "[ERROR]"
	}
	return "[OK]"
}

// ======= ./workerpool/public.go =======
// Package workerpool - пакет служащий для реализации паттерна workerpool
// Внешние функции для вызова в main
// Запись в задач в канал, выдача канала с результатом, ожидание выполнение горутин
package workerpool

import (
	"encoding/json"
	"fmt"
	"os"
	"os/signal"
	"syscall"
)

func (p *Pool) WriteChanIn(urls []string) {
	go func() {
		for _, url := range urls {
			p.in <- url
		}
	}()
}

func (p *Pool) ResOutChan() <-chan Result {
	return p.out
}

func (p *Pool) Wait() {
	go func() {
		p.wg.Wait()
		close(p.out)
	}()
}

func LoadUrls(filename string) ([]string, error) {
	data, err := os.ReadFile(filename)
	if err != nil {
		return nil, fmt.Errorf("не найден файл %s: %w", filename, err)
	}

	var urls []string
	if err := json.Unmarshal(data, &urls); err != nil {
		return nil, fmt.Errorf("неверный формат файла %s: %w", filename, err)
	}
	return urls, nil
}

func GracefulShutdown(pool *Pool) {
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGTERM, syscall.SIGINT)
	<-quit
	fmt.Println("[INFO] Signal stopped...stop pool")
	pool.Stop()
	fmt.Println("[EXIT] Pool stopped corect")
}

func (p *Pool) Stop() {
	p.mu.Lock()
	defer p.mu.Unlock()

	if p.stopped {
		return
	}

	p.stopped = true
	close(p.in)
	p.wg.Wait()
}

// ======= ./README.md =======
# PingPool

**PingPool** — простой инструмент на Go для пинга веб-сайтов.  

В примере уже приведены несколько URL для проверки работы.  
Пинг выполняется **один раз** для каждого сайта, бесконечный цикл не используется. 

// ======= ./go.mod =======
module ping/app

go 1.24.6

// ======= ./urls.json =======
[
  "https://ya.ru/",
  "https://www.google.com/",
  "https://vk.com",
  "https://netology.ru"
]

